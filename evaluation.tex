\chapter{Evaluation}

This section presents a comprehensive evaluation of the proposed trading
mechanism, focusing on its performance, scalability, and overall effectiveness
in multi cluster environments. We employ a combination of synthetic and
real-world workloads to simulate various scenarios, alongside an array of rules
and policies to investigate beneficial strategies and the effectiveness of
different workload-strategy combinations.

However, the possible combinations of rules, policies and their respective
configurations is infinite. Our aim in this section is not to exhaust all
possibilities, but to explore the validity of the mechanism under different
constraints. This approach paves the way for users to conduct their experiments
on thier specific workloads to determine the strategies that best fits their
needs.  

All experiments are run on Cloudlab, a scientific infrastructure used by
academics for systems and cloud research \cite{duplyakin_design_2019}. We utilize the following
setups to to run the experiments. Each node in the setups simulates one
cluster, with the cluster, trader, and client running on the same machine. 
% CITE CLOUDLAB NODES
\begin{enumerate}

  \item \textbf{Setup One:} 3 Cloudlab nodes c6525-100g running Linux
    Ubuntu 22.04 in the same Utah datacenter. Cluster sizes are equal having 10
    nodes each with 32 cores and 24GBs of memory.

  \item \textbf{Setup Two:} 3 Cloudlab nodes of type m510, c220g1, c8220 running on three distinct datacenters in Utah, Wisconsin,
    and Clemson, and have the same cluster sizes as setup one.

\end{enumerate}

The setups simulate different scenarios where clusters can belong to one
organization, different organizations, and have varying network latency and
bandwidth.  

We derive our results by running a configuration of rules, policies, and
workloads twice, once with and once without the mechanism and compare the
performance difference.

Our methodology for running workloads is as follows, all participating clusters
have the same start and end time for receiving jobs from their respective
clients. After the clients stop sending jobs, the experiment is kept on until
the last job in the slowest cluster finish execution. 

\section{Experiment One}

\begin{center}
  \fbox{\parbox{14cm}{
  
    \underline{Configuration:}
    \vspace{.3em}
    \begin{enumerate}
  
      \item \textbf{Setup:} \#1 with three cooperative clusters.
  
      \item \textbf{Workload:} Synthetic, all clusters are over-subscribed.
      
      \item \textbf{Rules:} Approve trades if average wait time is below 5
        seconds and both memory and core utilization below 0.8
      
      \item \textbf{Policies:} Initiate trades if utilization is above 0.8 or
        average wait time above 60 seconds.
  
    \end{enumerate}
  }}
\end{center}
We will first examine the scenario where all cooperative clusters have high
resource utilization for the entirety of the experiment duration.

%We aim by this experiment to showcase the overhead of the trading mechanism
%where it's likely not beneficial to participate.

\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./figures/experiment-one/cooperative-clusters-all-at-100-trading-mem-util.png}
  \caption{cooperative clusters}
  \label{fig:exp1coop}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./figures/experiment-one/control-mem-util.png}
  \caption{control cluster}
  \label{fig:exp1control}
\end{subfigure}
\caption{experiment 1, memory utilization}
\label{fig:exp1memutil}
\end{figure}

Figure~\ref{fig:exp1memutil} presents the memory utilization of the cooperative
clusters in \ref{fig:exp1coop} and the same workload run on a cluster without
trading in \ref{fig:exp1control}.
% analysis
We can see that the control cluster have a slightly less utilization averaging
at 70\% whereas cooperative cluster's memory utilization averaged at 75\%. This
5\% difference is due to cooperative clusters doing quick trades during short
down time intervals, leading to an inefficient scheduling and coupled with
higher utilization. In this case, trading is discouraged or a higher buffer
between trades would benefit performance. We can draw the same conclusion for
core utilization with 65\% and 71\%. However, this led to a 5.45\% increase in
total time to finish all jobs as local resources where occationally lent just
before a spike in jobs, delaying the execution of the local ones. As this
phenomenon happened on all clusters, they all suffered decreased perforamnce.
It's important to mention that a cluster can't evict external allocations once
the contract is approved, hence a trade can be expensive without proper
considerations.

We can see this effect play out in the number of jobs in the scheduler's queues.
\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{./figures/experiment-one/jobs-in-queue.png}
  \end{center}
  \caption{}\label{fig:exp-1-jobs-in-queue}
\end{figure}

As you can see in figure~\ref{fig:exp-1-jobs-in-queue}, all participating
clusters incurred an increased number of jobs in the queue at the peak. Note
that the peak is created because of our workload methodology. The decreasing
part of the graph resembles the cool down time, or the time it takes to finish
scheduling all jobs after the client finish sending them. As all these clusters
are over subscribed, jobs keep on getting queued until the client finish
sending jobs. The total workload per cluster in this experiment was around 8000
jobs. 

\section{Experiment Two}

\begin{center}
  \fbox{\parbox{14cm}{
  
    \underline{Configuration:}
    \vspace{.3em}
    \begin{enumerate}
  
      \item \textbf{Setup:} \#1 with three cooperative clusters.
  
      \item \textbf{Workload:} Synthetic 
        \vspace{-.5em}
          \begin{enumerate}
            \item One under utilized. 
            \item One highly utilized. 
            \item One overly subscribed. 
          \end{enumerate} 
      
      \item \textbf{Rules:} Approve trades if average wait time is below 5
        seconds and both memory and core utilization below 0.8
      
      \item \textbf{Policies:} Initiate trades if utilization is above 0.8 or
        average wait time above 60 seconds.
  
    \end{enumerate}
  }}
\end{center}

In this experiment, we run trading on a simlar rule and policy configuration as
experiment one, with varying workloads between clusters, detailed in the
configuration box above. 

\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./figures/experiment-two/trading.png}
  \caption{cooperative clusters}
  \label{fig:exp2coop}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./figures/experiment-two/control.png}
  \caption{control cluster}
  \label{fig:exp2control}
\end{subfigure}
\caption{experiment 2, core utilization}
\label{fig:exp2coreutil}
\end{figure}

Figure~\ref{fig:exp2coreutil} displays the core utilization of the cooperative
clusters in \ref{fig:exp2coop} and the same workload run on a cluster without
trading in \ref{fig:exp2control}.
% analysis
The first evident difference between the two graphs is the spikes seen on the
10 jobs/minute cluster and less apperent the 50 jobs/minute cluster. These
indicate the occurance of trades, benefiting the highly utilized 100
jobs/minute cluster. Trading did not negatively effect the performance of any
of the particpating cluster, and decreased the total time to finish all jobs in
the environment by 5.8\%, from 7 hours and 28 minutes to 7 hours.

\section{Experiment Three}

\begin{center}
  \fbox{\parbox{14cm}{
  
    \underline{Configuration:}
    \vspace{.3em}
    \begin{enumerate}
  
      \item \textbf{Setup:} \#1 with three cooperative clusters.

      \item \textbf{Workload:} Synthetic
          \vspace{-.5em}
          \begin{enumerate}
            \item Two highly utilized clusters
            \item One small cluster with varying utilization levels 
          \end{enumerate} 
      \item \textbf{Rules:} Approve trades if average wait time is below 5
        seconds and both memory and core utilization below 0.8
      
      \item \textbf{Policies:} Initiate trades if utilization is above 0.8 or
        average wait time above 60 seconds.
  
    \end{enumerate}
  }}
\end{center}

This experiment models a scenario with some similarity to the machine learning
training-inference workloads the Lyra system took advantage of
\cite{li_lyra_2023}, albeit with some differences. There are two big highly
utilized clusters, and one small cluster experiencing low utilization in
addition to spikes. We kept the rules and policies similar to the previous
experiments for reference. The figure below shows the memory utilization of
these clusters. 

\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./figures/experiment-three/cooperative.png}
  \caption{cooperative clusters}
  \label{fig:exp3coop}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./figures/experiment-three/control.png}
  \caption{control cluster}
  \label{fig:exp3control}
\end{subfigure}
\caption{experiment 3, memory utilization}
\label{fig:exp3memutil}
\end{figure}

The small cluster did not incur any degradation for loaning its resources, as
job completion time and total time to finish all jobs remained the same. The
highly utilized clusters were able to manage their workloads for most of the
experiment, with the small cluster experiencing only 15\% increase in
utilization. This led to a  4\% reduction in time to schedule all jobs in the
highly utilized clusters. 


%\section{Experiment Four}

% the goal is to test different policies and see which ones, coupled with the
% appropriate workload, achieves one of the goals stated in the thesis
% statement.
%\section{Limitations}
%
%- workload overfitting
%https://www.usenix.org/system/files/conference/atc18/atc18-amvrosiadis.pdf
%
%- simulation not actual system
